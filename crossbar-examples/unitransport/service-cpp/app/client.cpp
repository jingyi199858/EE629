#include <autobahn/autobahn.hpp>
#include <boost/asio.hpp>
#include <boost/version.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <chrono>
#include <iostream>
#include <memory>
#include <string>
#include <tuple>

static const std::string this_service = "service2";
static const std::vector<std::string> other_services = {"service0", "service1", "service3"};


void add2(autobahn::wamp_invocation invocation)
{
    auto a = invocation->argument<uint64_t>(0);
    auto b = invocation->argument<uint64_t>(1);

    std::cerr << "AutobahnCpp/REGISTER: add2 invoked: " << this_service << ": " << a << ", " << b << std::endl;

    invocation->result(std::make_tuple(a + b));
}

int main(int argc, char** argv)
{
    std::cerr << "Boost " << BOOST_VERSION << std::endl;

    try {
        boost::asio::io_service io;

        // resolve hostname "crossbar" to IP
        boost::asio::ip::tcp::resolver resolver(io);
        boost::asio::ip::tcp::resolver::query query("crossbar", "8080");
        boost::asio::ip::tcp::resolver::iterator iter = resolver.resolve(query);
        boost::asio::ip::tcp::endpoint endpoint = iter->endpoint();

        // this is how you could get an endpoint given an IP directly
        // boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::address::from_string(std::string("127.0.0.1")), 8080);

        auto transport = std::make_shared<autobahn::wamp_tcp_transport>(io, endpoint, false);

        auto session = std::make_shared<autobahn::wamp_session>(io, false);

        transport->attach(std::static_pointer_cast<autobahn::wamp_transport_handler>(session));

        // Make sure the continuation futures we use do not run out of scope prematurely.
        // Since we are only using one thread here this can cause the io service to block
        // as a future generated by a continuation will block waiting for its promise to be
        // fulfilled when it goes out of scope. This would prevent the session from receiving
        // responses from the router.
        boost::future<void> connect_future;
        boost::future<void> start_future;
        boost::future<void> join_future;
        boost::future<void> call_future;
        boost::future<void> leave_future;
        boost::future<void> stop_future;
        boost::future<void> provide_future;

        int counter = 0;
        boost::asio::deadline_timer timer(io, boost::posix_time::seconds(1));
        std::function<void ()> loop;

        connect_future = transport->connect().then([&](boost::future<void> connected) {
            try {
                connected.get();
            } catch (const std::exception& e) {
                std::cerr << e.what() << std::endl;
                io.stop();
                return;
            }
            std::cerr << "AutobahnCpp/CALL: transport connected" << std::endl;

            start_future = session->start().then([&](boost::future<void> started) {
                try {
                    started.get();
                } catch (const std::exception& e) {
                    std::cerr << e.what() << std::endl;
                    io.stop();
                    return;
                }

                std::cerr << "session started" << std::endl;

                join_future = session->join(std::string("realm1")).then([&](boost::future<uint64_t> joined) {
                    try {
                        std::cerr << "joined realm: " << joined.get() << std::endl;

                    } catch (const std::exception& e) {
                        std::cerr << e.what() << std::endl;
                        io.stop();
                        return;
                    }

                    // SUBSCRIBE to a topic and receive events
                    //

                    // REGISTER (aka "PROVIDE") a procedure
                    //
                    provide_future = session->provide("com.example." + this_service + ".add2", &add2).then(
                        [&](boost::future<autobahn::wamp_registration> registration) {
                        try {
                            std::cerr << "AutobahnCpp/REGISTER: registered procedure:" << registration.get().id() << std::endl;
                        } catch (const std::exception& e) {
                            std::cerr << e.what() << std::endl;
                            io.stop();
                            return;
                        }
                    });

                    // PUBLISH and CALL every second .. forever
                    //
                    loop = [&]() {
                        timer.async_wait([&](boost::system::error_code) {

                        // CALL
                        //
                        autobahn::wamp_call_options call_options;
                        call_options.set_timeout(std::chrono::seconds(10));
                        std::tuple<uint64_t, uint64_t> arguments(23 + counter, 777);

                        for (size_t i = 0; i < other_services.size(); ++i) {
                            call_future = session->call("com.example." + other_services[i] + ".add2", arguments, call_options).then(
                                [&](boost::future<autobahn::wamp_call_result> result) {
                                    try {
                                        uint64_t sum = result.get().argument<uint64_t>(0);
                                        std::cerr << "AutobahnCpp/CALL: call result: " << sum << std::endl;
                                    } catch (const std::exception& e) {
                                        std::cerr << "AutobahnCpp/CALL: call failed: " << e.what() << std::endl;
                                    }
                                }
                            );
                        }

                        // PUBLISH an event
                        //
                        for (size_t i = 0; i < other_services.size(); ++i) {
                            std::string topic = "com.example." + other_services[i] + ".on_counter";
                            std::tuple<int> arguments(counter);
                            session->publish(topic, arguments);
                            std::cerr << "AutobahnCpp/PUBLISH: event published to " << topic << std::endl;
                        }

                        timer.expires_at(timer.expires_at() + boost::posix_time::seconds(1));
                        loop();
                        });
                    };

                    loop();
                });
            });
        });

        std::cerr << "starting io service" << std::endl;
        io.run();
        std::cerr << "stopped io service" << std::endl;

        transport->detach();
    }
    catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }

    return 0;
}
